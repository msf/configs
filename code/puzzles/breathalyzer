#!/usr/bin/env python

import sys

#good_words_list = '/var/tmp/twl06.txt'
good_words_list = 'twl06.txt'

alphabet = 'abcdefghijklmnopqrstuvwxyz'.upper()

def edits1(word):
    n = len(word)
    return set([word[0:i]+word[i+1:] for i in range(n)] + # deletion
# trans not counted.  [word[0:i]+word[i+1]+word[i]+word[i+2:] for i in range(n-1)] + # transposition
               [word[0:i]+c+word[i+1:] for i in range(n) for c in alphabet] + # substitution
               [word[0:i]+c+word[i:] for i in range(n+1) for c in alphabet]) # insertion


def damlev_distance( word1, word2, max_cost ):
    """ Damerau-Levenshtein Distance is a "distance" (string metric) between two strings,
    i.e., finite sequence of symbols, given by counting the minimum number of operations
    needed to transform one string into the other, where an operation is defined as an
    insertion, deletion, or substitution of a single character, or a transposition of two characters.
    -- NOTE: this isn't correct because for exercise purposes transposion is counted has 2 substitutions.
    """

    len1 = len(word1) +1
    len2 = len(word2) +1
    d = [ [0]*len2 for i in xrange(len1) ]
    i = 0
    j = 0
    cost = 0
    for i in xrange( len1 ):
        d[i][0] = i
    for j in xrange( len2 ):
        d[0][j] = j
    for i in xrange(1, len1 ):
        for j in xrange(1, len2 ):
            if word1[i-1] == word2[j-1]:
                cost = 0
            else:
                cost = 1
            deletion     = d[i-1][j] +1
            insertion    = d[i][j-1] +1
            substitution = d[i-1][j-1] + cost
#            transposition= d[i-2][j-2] + cost
            cost = min(deletion, insertion, substitution)
#            if i > 0 and j > 0 and word1[i] == word2[j-1] and word[i-1] == word2[j]:
#                 d[i][j] = min( d[i][j], transposition )
            if i == j and cost > max_cost:
                return cost
            d[i][j] = cost
    return d[len1-1][len2-1]


def breathalizer(good_words, words):
    total_score = 0
    cache = {}
    for w in words:
        stop_word = False

        # good word
        if w in good_words:
            continue

        # repeated word
        if w in cache:
            total_score += cache[w]
            continue

        # distance of 1 from a good word ?
        for edit1 in edits1(w):
            if edit1 in good_words:
                cache[w] = 1
                stop_word = True
                break
        if stop_word:
            total_score += cache[w]
            continue

        # minimum damerau-levenshtein distance from list of good words
        best = len(w)
        for gw in good_words.keys():
            best = min(damlev_distance(w, gw, best), best)
            if best == 1:
                break
        cache[w] = best
        total_score += best

    return total_score


file = open(sys.argv[1],"r")

words = [ w for w in file.read().strip().upper().split() ]

good_file = open(good_words_list, "r")
good_words = {}
for w in good_file.read().split():
    good_words[w] = 1

print(breathalizer(good_words, words))

